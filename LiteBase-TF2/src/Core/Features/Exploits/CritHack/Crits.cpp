#include "Crits.h"
#include "../Engine Prediction/Prediction.h"
#include "../../../SDK/Include/TF2/globalinfo.h"
#define MASK_SIGNED 0x7FFFFFFF
#define me I::ClientEntityList->GetClientEntity(I::EngineClient->GetLocalPlayer())

// i hate crithack

/* Returns whether random crits are enabled on the server */
bool CCritHack::AreRandomCritsEnabled()
{
	if (static auto tf_weapon_criticals = I::CVar->FindVar("tf_weapon_criticals"); tf_weapon_criticals) {
		return tf_weapon_criticals->GetBool();
	}
	return true;
}

/* Returns whether the crithack should run */
bool CCritHack::IsEnabled()
{
	const auto& pLocal = g_EntityCache.GetLocal();
	if (!Vars::CritHack::Active.var) { return false; }
	if (!I::EngineClient->IsInGame() || !I::EngineClient->IsConnected( ) ) { return false; }
	if (!pLocal || pLocal->deadflag()) { return false; }
	if (!AreRandomCritsEnabled()) { return false; }

	return true;
}

bool CCritHack::ShouldCrit()
{
	if (GetAsyncKeyState(Vars::CritHack::CritKey.var) & 0x8000) { return true; }
	//if (g_GlobalInfo. == EWeaponType::MELEE && Vars::CritHack::AlwaysMelee.Value) { return true; }

	return false;
}

bool CCritHack::IsAttacking(const CUserCmd* pCmd, CTFWeaponBase* pWeapon)
{
	if (g_GlobalInfo.m_nCurItemDefIndex == Soldier_m_TheBeggarsBazooka)
	{
		static bool bLoading = false;

		if (pWeapon->m_iClip1() > 0)
		{
			bLoading = true;
		}

		if (!(pCmd->buttons & IN_ATTACK) && bLoading)
		{
			bLoading = false;
			return true;
		}
	}

	else
	{
		if (pWeapon->GetWeaponID() == TF_WEAPON_COMPOUND_BOW || pWeapon->GetWeaponID() == TF_WEAPON_PIPEBOMBLAUNCHER)
		{
			static bool bCharging = false;

			if (pWeapon->As<CTFPipebombLauncher>()->m_flChargeBeginTime() > 0.0f)
			{
				bCharging = true;
			}

			if (!(pCmd->buttons & IN_ATTACK) && bCharging)
			{
				bCharging = false;
				return true;
			}
		}

		//pssst..
		//Dragon's Fury has a gauge (seen on the weapon model) maybe it would help for pSilent hmm..
		/*
		if (pWeapon->GetWeaponID() == TF_WEAPON_FLAME_BALL) {

		}*/

		else
		{
			if ((pCmd->buttons & IN_ATTACK) && g_GlobalInfo.m_bWeaponCanAttack)
			{
				return true;
			}
		}
	}

	return false;
}

/* Returns the next crit command number */
int CCritHack::NextCritTick(const CUserCmd* pCmd, int loops = 128)
{
	static int previousWeapon = 0;
	static int previousCrit = 0;

	const auto& pLocal = g_EntityCache.GetLocal();
	if (!pLocal) { return -1; }

	const auto& pWeapon = g_EntityCache.GetWeapon();
	if (!pWeapon) { return -1; }

	// Return previous crit tick if it's still good
	if (previousWeapon == pWeapon->entindex() && previousCrit >= pCmd->command_number) { return previousCrit; }

	// Find the next crit tick
	int foundTick = -1;
	const int seedBackup = MD5_PseudoRandom(pCmd->command_number) & MASK_SIGNED;
	g_GlobalInfo.critTick = 0;
	g_GlobalInfo.m_bFoundCrit = false;
	for (g_GlobalInfo.currentTickLoop = 0; g_GlobalInfo.currentTickLoop < loops; g_GlobalInfo.currentTickLoop++)
	{
		const int cmdNum = pCmd->command_number + g_GlobalInfo.currentTickLoop;
		*I::RandomSeed = MD5_PseudoRandom(cmdNum) & MASK_SIGNED;
		if (pWeapon->WillCrit())
		{
			previousCrit = cmdNum;
			previousWeapon = pWeapon->entindex();
			foundTick = cmdNum;
			g_GlobalInfo.critTick = cmdNum;
			g_GlobalInfo.m_bFoundCrit = true;
			break;
		}
	}

	*reinterpret_cast< int * >( reinterpret_cast<DWORD>( pWeapon ) + 0xA5C ) = 0;
	*I::RandomSeed = seedBackup;
	return foundTick;
}

void CCritHack::Run(CUserCmd* pCmd)
{
	if (!IsEnabled()) { return; }

	const auto& pWeapon = g_EntityCache.GetWeapon();
	if (!pWeapon || !pWeapon->CanFireCriticalShot(false)) { return; }

	int nextCrit = NextCritTick(pCmd);
	g_GlobalInfo.m_bPreventingCrit = false;
	if (nextCrit >= 0 && IsAttacking(pCmd, pWeapon))
	{
		if (ShouldCrit())
		{
			// Force next crit
			pCmd->command_number = nextCrit;
			pCmd->random_seed = MD5_PseudoRandom(nextCrit) & MASK_SIGNED;
		}
		else if (Vars::CritHack::AvoidRandom.var)
		{
			// Prevent crit
			g_GlobalInfo.preventTick = 0;
			while (pCmd->command_number == nextCrit && g_GlobalInfo.preventTick < 10)
			{
				g_GlobalInfo.m_bPreventingCrit = true;
				pCmd->command_number++;
				pCmd->random_seed = MD5_PseudoRandom(pCmd->command_number) & MASK_SIGNED;
				nextCrit = NextCritTick(pCmd, 5);
				g_GlobalInfo.preventTick++;
			}
		}
	}

	// TODO: Fix the crit bucket
}

/*void CCritHack::Render( )
{
	if ( !I::EngineClient->IsInGame( ) || !I::EngineClient->IsConnected( ) ) { return; }

	if ( !AreRandomCritsEnabled( ) ) 
	{
		g_Draw.String( g_Fonts[ EFonts::IND ].m_dwFont, g_Draw.m_nScreenW * 0.5f, g_Draw.m_nScreenH * 0.6f , { 150, 150, 150, 255 }, ALIGN_CENTERHORIZONTAL, "Server disabled crits" );
	}
	else
	{
		const auto &pLocal = g_EntityCache.GetLocal( );
		if ( pLocal && !pLocal->IsDormant( ) && !pLocal->deadflag( ) )
		{
			const auto &pWeapon = g_EntityCache.GetWeapon( );
			auto data = pWeapon->GetWeaponData( );
			const int bucket = *reinterpret_cast< int * >( reinterpret_cast< DWORD >( pWeapon ) + 0xA54 );
			int damage;

			if ( g_GlobalInfo.m_WeaponType == EWeaponType::HITSCAN )
			{
				damage = ( data.m_nDamage * data.m_nBulletsPerShot ) * 3;
			}
			else if ( g_GlobalInfo.m_WeaponType == EWeaponType::PROJECTILE )
			{
				damage = ( data.m_nDamage ) * 3;
			}
			else
			{
				damage = ( data.m_nDamage ) * 3;
			}

			if ( damage > 0 )
			{
				int max = g_ConVars.tf_crit_cap->GetInt( );
				int crits = max / damage;
				g_Draw.String( g_Fonts[ EFonts::IND ].m_dwFont, g_Draw.m_nScreenW * 0.5f, g_Draw.m_nScreenH * 0.6f, { 150, 150, 150, 255 }, ALIGN_CENTERHORIZONTAL, "%i potential crits", crits );
			}

			if ( bucket == 1000 )
			{
				g_Draw.String( g_Fonts[ EFonts::IND ].m_dwFont, g_Draw.m_nScreenW * 0.5f, g_Draw.m_nScreenH * 0.6f, { 150, 150, 150, 255 }, ALIGN_CENTERHORIZONTAL, "crit bucket full" );
			}
		}
	}
}*/