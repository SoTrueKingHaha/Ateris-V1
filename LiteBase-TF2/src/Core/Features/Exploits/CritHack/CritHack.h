#pragma once
#include "../../../SDK/SDK.h"

enum iscrit_t
{
	// Server observed us firing too many crits
	ISCRIT_OBSERVED_CAP = -5,
	// Crit bucket is empty
	ISCRIT_BUCKET_EMPTY = -4,
	// CanFireCritShot() returns false
	ISCRIT_CANNOT_CRIT = -3,
	// Seed reused
	ISCRIT_REUSED_SEED = -2,
	// Just finished streaming crits, wait 1 sec
	ISCRIT_STREAM_WAIT = -1,
	// Next  crit is determined by random chance
	ISCRIT_RANDOM = 0,
	// Currently critboosted
	ISCRIT_BOOSTED = 3,
	// Currently streaming crits
	ISCRIT_STREAMING = 4,
};

class CCritHack {
private:
	bool AreRandomCritsEnabled( );
	void GetState( CTFWeaponBase *pWeapon );
	//bool ShouldForceMelee(CBaseCombatWeapon* pWeapon);	//	compare distances between local & enemies, force crits if we are within swing range of enemy.
	bool IsAttacking( const CUserCmd *pCmd, CTFWeaponBase *pWeapon );
	void ScanForCrits( const CUserCmd *pCmd, int loops = 10 );
	int LastGoodCritTick( const CUserCmd *pCmd );
	//int DamageToNextCrit(CBaseCombatWeapon* pWeapon);	//	returns a positive value if we are crit banned

	bool WeaponCanCrit( CTFWeaponBase *pWeapon );
	bool CanFireRandomCriticalShot( CTFWeaponBase *pWeapon, float flChance );
	int GetDamage( CTFWeaponBase *pWeapon );
	int GetMeleeDamage( CTFWeaponBase *pWeapon );
	float AttackDamage( CTFWeaponBase *pWeapon );
	void AddCritBucket( float flDamage );
	bool BlowCritBucket( float flDamage );
	bool IsCrit( CTFPlayer* pLocal, CTFWeaponBase *pWeapon, iscrit_t &crit );

	std::vector<int> CritTicks{};

	//	TODO: Create & Restore to & from this struct when scanning for crits.
	//	Stop messing around with AddToBucket etc, just change values when scanning if needed.

	enum EWeaponStrangeType_t
	{
		STRANGE_UNKNOWN = -1,
		STRANGE_NOT_STRANGE = 0,
		STRANGE_IS_STRANGE = 1,
	};

	enum EWeaponStatTrakModuleType_t
	{
		MODULE_UNKNOWN = -1,
		MODULE_NONE = 0,
		MODULE_FOUND = 1,
	};

	struct state_t
	{
		/*0xAAC*/ bool bCurrentAttackIsCrit;
				  bool m_bCurrentCritIsRandom;
				  bool m_bCurrentAttackIsDuringDemoCharge;
				  EWeaponStrangeType_t m_eStrangeType;
				  EWeaponStatTrakModuleType_t m_eStatTrakModuleType;
		/*0xAAD*/ bool bLowered;//NETVAR
		/*0xAB0*/ int iAltFireHint;
		/*0xAB4*/ int iReloadStartClipAmount;
		/*0xAB8*/ float flCritEndTime;
		/*0xABC*/ float flLastCritCheckTime;//NETVAR
		/*0xAC0*/ int iLastCritCheckFrame;
		/*0xAC4*/ int iCurrentSeed;
		/*0xAC8*/ float flLastCritCheckTimeNoPred;
	} state;

public:
	void Run( CUserCmd *pCmd );
	bool IsEnabled( );
	bool ShouldCrit( );
	void Render( );

	struct stats_t
	{
		//float flCritBucket[ 3 ] = { 300, 300, 300 };	// 0xA54
		std::array<float, 3> flCritBucket = { 300, 300, 300 };
		int iNumAttacks;			// 0xA58
		int iNumCrits;				// 0xA5C
		float flCritCost;
		float flDamage;
	} stats;

	/*int IndicatorW;
	int IndicatorH;*/
	bool ProtectData = false;
	bool bIsMelee = false;
	bool bStreamCrits = false;
	bool bCanCrit = false;
};

inline CCritHack g_Crits;