#include "CritHack.h"
#include "../Engine Prediction/Prediction.h"
#define MASK_SIGNED 0x7FFFFFFF

// i hate crithack
bool CCritHack::WeaponCanCrit( CTFWeaponBase *pWeapon )
{
	bool result = true;
	switch ( pWeapon->m_iItemDefinitionIndex( ) )
	{
		case Scout_s_MadMilk:
		case Scout_s_MutatedMilk:
		case Scout_s_BonkAtomicPunch:
		case Scout_s_CritaCola:
		case Soldier_m_RocketJumper:
		case Soldier_t_TheMarketGardener:
		case Soldier_s_TheBuffBanner:
		case Soldier_s_FestiveBuffBanner:
		case Soldier_s_TheConcheror:
		case Soldier_s_TheBattalionsBackup:
		case Pyro_m_DragonsFury:
		case Pyro_m_ThePhlogistinator:
		case Pyro_s_TheManmelter:
		case Pyro_s_GasPasser:
		case Pyro_t_NeonAnnihilator:
		case Pyro_t_NeonAnnihilatorG:
		case Pyro_t_TheAxtinguisher:
		case Pyro_t_TheFestiveAxtinguisher:
		case Pyro_t_ThePostalPummeler:
		case Demoman_s_StickyJumper:
		case Demoman_t_UllapoolCaber:
		case Engi_m_ThePomson6000:
		case Engi_m_TheFrontierJustice:
		case Engi_m_FestiveFrontierJustice:
		case Engi_s_TheShortCircuit:
		case Engi_s_TheWrangler:
		case Engi_s_FestiveWrangler:
		case Engi_s_TheGigarCounter:
		case Engi_t_TheGunslinger:
		case Engi_t_TheSouthernHospitality:
		case Sniper_m_TheHuntsman:
		case Sniper_m_TheFortifiedCompound:
		case Sniper_s_Jarate:
		case Sniper_s_TheSelfAwareBeautyMark:
		case Sniper_t_TheBushwacka:
		case Spy_m_TheAmbassador:
		case Spy_m_FestiveAmbassador:
		case Spy_m_TheDiamondback:
		case Spy_m_TheEnforcer:
		{
			result = false;
			break;
		}
		default:
		{
			switch ( pWeapon->GetWeaponID( ) )
			{
				case TF_WEAPON_SNIPERRIFLE:
				case TF_WEAPON_SNIPERRIFLE_CLASSIC:
				case TF_WEAPON_SNIPERRIFLE_DECAP:
				case TF_WEAPON_SMG:
				case TF_WEAPON_PISTOL:
				case TF_WEAPON_FLAREGUN:
				case TF_WEAPON_HANDGUN_SCOUT_PRIMARY:
				case TF_WEAPON_CLEAVER:
				case TF_WEAPON_FLAMETHROWER:
				case TF_WEAPON_FLAMETHROWER_ROCKET:
				case TF_WEAPON_MEDIGUN:
				case TF_WEAPON_SWORD:
				case TF_WEAPON_SYRINGEGUN_MEDIC:
				case TF_WEAPON_KNIFE:
				case TF_WEAPON_PDA_SPY:
				case TF_WEAPON_BUILDER:
				case TF_WEAPON_PDA_SPY_BUILD:
				case TF_WEAPON_PDA:
				case TF_WEAPON_PDA_ENGINEER_BUILD:
				case TF_WEAPON_PDA_ENGINEER_DESTROY:
				case TF_WEAPON_PARTICLE_CANNON:
				case TF_WEAPON_LUNCHBOX:
				{
					result = false;
					break;
				}
			}
		}
	}

	return result;
}

int CCritHack::GetDamage( CTFWeaponBase *pWeapon )
{
	auto data = pWeapon->GetWeaponData( );
	int Damage = data.m_nDamage;
	switch ( pWeapon->GetWeaponID( ) )
	{
		case TF_WEAPON_CANNON:
		{
			Damage = 84;
			break;
		}
		case TF_WEAPON_ROCKETLAUNCHER:
		{
			Damage = 70;
			break;
		}
		case TF_WEAPON_MINIGUN:
		{
			Damage = 1;
			break;
		}
		default: { Damage = data.m_nDamage; break; };
	}
	return Damage;
}

int CCritHack::GetMeleeDamage( CTFWeaponBase *pWeapon )
{
	int MeleeDamage = 65;

	switch ( pWeapon->m_iItemDefinitionIndex( ) )
	{
		case Scout_t_SunonaStick:
		{
			//The Sun on a Stick has a -25% melee damage stat
			MeleeDamage = 26;
			break;
		}
		case Scout_t_TheFanOWar:
		{
			//The Fan O'War has a -75% melee damage stat
			MeleeDamage = 9;
			break;
		}
		case Scout_t_TheWrapAssassin:
		{
			//The Wrap Assassin has a -65% melee damage stat
			MeleeDamage = 12;
			break;
		}
		case Soldier_t_TheDisciplinaryAction:
		case Engi_t_TheJag:
		{
			//The Disciplinary Action and The Jag have a -25% melee damage stat
			MeleeDamage = 49;
			break;
		}
		case Soldier_t_TheEqualizer:
		{
			//The Equalizer does more damage the lower the local player's health is
			break;
		}
		case Pyro_t_HotHand:
		{
			//The Hot Hand has a -20% melee damage stat
			MeleeDamage = 28;
			break;
		}
		case Pyro_t_SharpenedVolcanoFragment:
		case Medic_t_Amputator:
		{
			//The Sharpened Volcano Fragment and The Amputator have a -20% melee damage stat
			MeleeDamage = 52;
			break;
		}
		case Pyro_t_TheBackScratcher:
		{
			//The Back Scratcher has a +25% melee damage stat
			MeleeDamage = 81;
			break;
		}
		case Demoman_t_TheScotsmansSkullcutter:
		{
			//The Scotsmans Skullcutter has a +20% melee damage stat
			MeleeDamage = 78;
			break;
		}
		case Heavy_t_WarriorsSpirit:
		{
			//The Warriors Spirit has a +30% melee damage stat
			MeleeDamage = 85;
			break;
		}
		case Sniper_t_TheTribalmansShiv:
		{
			//The Tribalmans Shiv has a -50% melee damage stat
			MeleeDamage = 37;
			break;
		}
		case Sniper_t_TheShahanshah:
		{
			//The Shahanshah has a -25% melee damage stat when above half health and a +25% when below half health
			//81 if below half health
			//49 if above half health
			break;
		}
		default: break;
	}

	return MeleeDamage;
}

bool CCritHack::CanFireRandomCriticalShot( CTFWeaponBase *pWeapon, float flChance )
{
	float flObservedCritCap = flChance + 0.1f;
	return pWeapon->m_flObservedCritChance( ) <= flObservedCritCap;
}

float CCritHack::AttackDamage( CTFWeaponBase *pWeapon )
{
	auto data = pWeapon->GetWeaponData( );
	int nBulletsPerShot = bIsMelee ? 1 : data.m_nBulletsPerShot;
	int damage = bIsMelee ? GetMeleeDamage( pWeapon ) : GetDamage( pWeapon );
	float flDamage = g_GlobalInfo.m_WeaponType == EWeaponType::PROJECTILE ? damage : damage * static_cast< float >( nBulletsPerShot );
	return flDamage;
}

void CCritHack::AddCritBucket( float flDamage )
{
	const auto &pWeapon = g_EntityCache.GetWeapon( );
	switch ( pWeapon->GetSlot( ) )
	{
		case 0:
		{
			if ( stats.flCritBucket[ 0 ] < 1000.0f )
			{
				stats.flCritBucket[ 0 ] = std::min( stats.flCritBucket[ 0 ] + flDamage, 1000.0f );
			}
			break;
		}
		case 1:
		{
			if ( stats.flCritBucket[ 1 ] < 1000.0f )
			{
				stats.flCritBucket[ 1 ] = std::min( stats.flCritBucket[ 1 ] + flDamage, 1000.0f );
			}
			break;
		}
		case 2:
		{
			if ( stats.flCritBucket[ 2 ] < 1000.0f )
			{
				stats.flCritBucket[ 2 ] = std::min( stats.flCritBucket[ 2 ] + flDamage, 1000.0f );
			}
			break;
		}
		default: break;
	}
}

bool CCritHack::BlowCritBucket( float flDamage )
{
	stats.iNumCrits++;
	// Calculate the cost of firing a critical hit
	float flCostMult;
	float critbucket = 300;
	const auto &pWeapon = g_EntityCache.GetWeapon( );
	switch ( pWeapon->GetSlot( ) )
	{
		case 0:
		{
			critbucket = stats.flCritBucket[ 0 ];
			break;
		}
		case 1:
		{
			critbucket = stats.flCritBucket[ 1 ];
			break;
		}
		case 2:
		{
			critbucket = stats.flCritBucket[ 2 ];
			break;
		}
		default: break;
	}

	if ( bIsMelee )
	{
		flCostMult = 0.5f;
	}
	else
	{
		float flCritRatio = static_cast< float >( stats.iNumCrits ) / static_cast< float >( stats.iNumAttacks );
		flCostMult = ( flCritRatio - 0.1f ) / 0.9f;
		flCostMult = std::max( flCostMult, 0.0f );
		flCostMult = std::min( flCostMult, 1.0f );
		flCostMult = flCostMult * 2.0f + 1.0f;
	}
	// Cost of firing a critical hit
	float flCritCost = bIsMelee ? flDamage * flCostMult : ( flDamage * 3.0f );
	stats.flCritCost = flCritCost;
	// If not enough damage stored, deny crit
	if ( flCritCost > critbucket )
	{
		return false;
	}
	// RemoveFromCritBucket()
	critbucket = std::max( critbucket - flCritCost, -250.f );

	switch ( pWeapon->GetSlot( ) )
	{
		case 0:
		{
			if ( pWeapon->GetWeaponID( ) == TF_WEAPON_MINIGUN )
			{
				stats.flCritBucket[ 0 ] = 0.f;
			}
			else
			{
				stats.flCritBucket[ 0 ] = critbucket;
			}
			break;
		}
		case 1:
		{
			stats.flCritBucket[ 1 ] = critbucket;
			break;
		}
		case 2:
		{
			stats.flCritBucket[ 2 ] = critbucket;
			break;
		}
		default: break;
	}

	return true;
}

bool CCritHack::IsCrit( CTFPlayer *pLocal, CTFWeaponBase *pWeapon, iscrit_t &crit )
{
	/*if ( !IsAttacking( g_GlobalInfo.currentUserCmd, pWeapon ) || !g_GlobalInfo.m_bWeaponCanAttack )
	{
		crit = ISCRIT_RANDOM;
		return false;
	}*/
	// pl = pWeapon->GetOwner() and dynamic_cast to C_TFPlayer
	// pl->IsPlayer() (why?!)
	// pWeapon->CanFireCriticalShot()

	float flCritMult = pLocal->m_iCritMult( );
	state = *reinterpret_cast< state_t * >( reinterpret_cast< DWORD >( pWeapon ) + 0xAAC );
	/*if ( pWeapon->GetWeaponID( ) == TF_WEAPON_MINIGUN )
	{
		auto data = pWeapon->GetWeaponData( );
		bStreamCrits = data.m_bUseRapidFireCrits;
	}*/

	if ( !pWeapon->CanFireCriticalShot( false ) )
	{
		crit = ISCRIT_CANNOT_CRIT;
		return false;
	}
	if ( pLocal->IsCritBoosted( ) )
	{
		crit = ISCRIT_BOOSTED;
		return true;
	}

	if ( bIsMelee )
	{
		flCritMult *= 0.15f;
		if ( *I::RandomSeed == state.iCurrentSeed )
		{
			// Dunno predict what will happen...
			crit = ISCRIT_REUSED_SEED;
			return false;
		}
		// Game does some logic with pMe->m_iNextMeleeCrit (NETVAR)
		//int iNextMeleeCrit = pMe->iNextMeleeCrit();
		//state.bCurrentAttackIsCrit = iNextMeleeCrit!=0;
		//if ( iNextMeleeCrit==2 )
		//{
		//    return true;
		//}
		bool result = ShouldCrit( );
		float flDamage = AttackDamage( pWeapon );
		if ( !result && IsAttacking( g_GlobalInfo.currentUserCmd, pWeapon ) )
		{
			AddCritBucket( flDamage );
			stats.iNumAttacks++;
		}
		if ( result && IsAttacking( g_GlobalInfo.currentUserCmd, pWeapon ) )
		{
			result = BlowCritBucket( flDamage );
			if ( !result )
			{
				crit = ISCRIT_BUCKET_EMPTY;
				return false;
			}
		}
		else
		{
			crit = ISCRIT_RANDOM;
			return result;
		}
	}
	else
	{
		// Still streaming crits
		if ( bStreamCrits && state.flCritEndTime > I::GlobalVars->curtime )
		{
			crit = ISCRIT_STREAMING;
			return true;
		}
		float flDamage = AttackDamage( pWeapon );
		bool result = ShouldCrit( );

		if ( !result && IsAttacking( g_GlobalInfo.currentUserCmd, pWeapon ) )
			AddCritBucket( flDamage );
		//[ebp+var_1] = 0
		//[pWeapon+0xAAB] = 1
		if ( bStreamCrits )
		{
			bool tf_weapon_criticals_nopred = true;
			if ( tf_weapon_criticals_nopred )
			{
				if ( state.flLastCritCheckTimeNoPred + 1.0f > I::GlobalVars->curtime )
				{
					crit = ISCRIT_STREAM_WAIT;
					return false;
				}
				//state.flLastCritCheckTimeNoPred = curtime;
			}
			/*else
			{
				if ( state.flLastCritCheckTime + 1.0f > I::GlobalVars->curtime )
				{
					crit = ISCRIT_STREAM_WAIT;
					return false;
				}
				//if ( state.flLastCritCheckTime!=curtime )
				//{
				//    state.flLastCritCheckTime = curtime;
				//}
			}*/
			// Modify flCritMult
			flCritMult = 1.0f / ( 2.0f / ( flCritMult * 0.02f ) - 2.0f );
			if ( *I::RandomSeed == state.iCurrentSeed )
			{
				// Dunno predict what will happen...
				crit = ISCRIT_REUSED_SEED;
				return false;
			}
		}
		else
		{
			// Modify flCritMult
			flCritMult *= 0.02f;
			if ( *I::RandomSeed == state.iCurrentSeed )
			{
				// Dunno predict what will happen...
				crit = ISCRIT_REUSED_SEED;
				return false;
			}
		}
		if ( I::Prediction->IsFirstTimePredicted( ) && IsAttacking( g_GlobalInfo.currentUserCmd, pWeapon ) )
		{
			stats.iNumAttacks++;
		}
		crit = ISCRIT_RANDOM;
		if ( result && IsAttacking( g_GlobalInfo.currentUserCmd, pWeapon ) )
		{
			if ( CanFireRandomCriticalShot( pWeapon, flCritMult ) )
			{
				// Adjust for stream crits
				if ( bStreamCrits )
				{
					auto data = pWeapon->GetWeaponData( );
					flDamage = 2.0f / data.m_flTimeFireDelay * flDamage;
					if ( ( flDamage * 3.0f ) > 1000.f )
					{
						flDamage = 1000.f / 3.0f;
					}
				}
				result = BlowCritBucket( flDamage );
				if ( !CanFireRandomCriticalShot( pWeapon, flCritMult ) )
				{
					crit = ISCRIT_BUCKET_EMPTY;
					bCanCrit = false;
				}
				bCanCrit = true;
				//if ( result )
				//{
				//    state.flCritEndTime = curtime + 2.0f;
				//}
			}
			else
			{
				bCanCrit = false;
				crit = ISCRIT_OBSERVED_CAP;
				result = false;
			}
		}
		return result;
	}
	crit = ISCRIT_RANDOM;
	return false;
}

/*bool CCritHack::IsCrit( CTFPlayer *pLocal, CTFWeaponBase *pWeapon, iscrit_t &crit )
{
	auto data = pWeapon->GetWeaponData( );
	bStreamCrits = data.m_bUseRapidFireCrits;
	float flCritMult = pLocal->m_iCritMult( );
	state_t &state = *reinterpret_cast< state_t * >( reinterpret_cast< DWORD >( pWeapon ) + 0xAAC );

	if ( !pWeapon->CanFireCriticalShot( false ) )
	{
		crit = ISCRIT_CANNOT_CRIT;
		return false;
	}
	if ( pLocal->IsCritBoosted( ) )
	{
		crit = ISCRIT_BOOSTED;
		return true;
	}
	if ( g_GlobalInfo.m_WeaponType == EWeaponType::MELEE )
	{
		bIsMelee = true;
	}
	else
	{
		bIsMelee = false;
	}

	if ( bIsMelee )
	{
		flCritMult *= 0.15f;
		if ( *I::RandomSeed == state.iCurrentSeed )
		{
			// Dunno predict what will happen...
			crit = ISCRIT_REUSED_SEED;
			return false;
		}
		float flDamage = AttackDamage( pWeapon );
		AddCritBucket( flDamage );
		stats.iNumAttacks++;
		bool result = static_cast< float >( Utils::RandIntSimple( 0, 9999 ) ) <= ( flCritMult * 10000.0f );
		if ( result && !BlowCritBucket( flDamage ) )
		{
			crit = ISCRIT_BUCKET_EMPTY;
			return false;
		}
		else
		{
			crit = ISCRIT_RANDOM;
			return result;
		}
	}
	else
	{
		
	}
}*/

//Returns whether random crits are enabled on the server 
bool CCritHack::AreRandomCritsEnabled( )
{
	static auto tf_weapon_criticals = g_ConVars.FindVar( "tf_weapon_criticals" );
	if ( tf_weapon_criticals )
	{
		return tf_weapon_criticals->GetBool( );
	}
	return true;
}

//Returns whether the crithack should run 
bool CCritHack::IsEnabled( )
{
	if ( !Vars::CritHack::Active.var ) { return false; }
	if ( !AreRandomCritsEnabled( ) ) { return false; }
	if ( !I::EngineClient->IsInGame( ) ) { return false; }

	return true;
}

bool CCritHack::IsAttacking( const CUserCmd *pCmd, CTFWeaponBase *pWeapon )
{
	if ( pWeapon->m_iItemDefinitionIndex( ) == Soldier_m_TheBeggarsBazooka )
	{
		static bool bLoading = false;

		if ( pWeapon->m_iClip1( ) > 0 )
		{
			bLoading = true;
		}

		if ( !( pCmd->buttons & IN_ATTACK ) && bLoading )
		{
			bLoading = false;
			return true;
		}
	}

	else
	{
		if ( pWeapon->GetWeaponID( ) == TF_WEAPON_COMPOUND_BOW || pWeapon->GetWeaponID( ) == TF_WEAPON_PIPEBOMBLAUNCHER || pWeapon->GetWeaponID( ) == TF_WEAPON_CANNON )
		{
			static bool bCharging = false;

			if ( pWeapon->As<CTFPipebombLauncher>( )->m_flChargeBeginTime( ) > 0.0f )
			{
				bCharging = true;
			}

			if ( !( pCmd->buttons & IN_ATTACK ) && bCharging )
			{
				bCharging = false;
				return true;
			}
		}

		//pssst..
		//Dragon's Fury has a gauge (seen on the weapon model) maybe it would help for pSilent hmm..
		
		/*if ( pWeapon->GetWeaponID( ) == 109 ) {
		}*/

		else
		{
			if ( ( pCmd->buttons & IN_ATTACK ) && g_GlobalInfo.m_bWeaponCanAttack )
			{
				return true;
			}
		}
	}

	return false;
}

bool CCritHack::ShouldCrit( )
{
	if ( GetAsyncKeyState( Vars::CritHack::CritKey.var ) & 0x8000 ) { return true; }

	return false;
}

int CCritHack::LastGoodCritTick( const CUserCmd *pCmd )
{
	int retVal = -1;
	bool popBack = false;

	for ( const auto &tick : CritTicks )
	{
		if ( tick >= pCmd->command_number )
		{
			retVal = tick;
		}
		else
		{
			popBack = true;
		}
	}

	if ( popBack )
	{
		CritTicks.pop_back( );
	}

	return retVal;
}

void CCritHack::ScanForCrits( const CUserCmd *pCmd, int loops )
{
	static int previousWeapon = 0;
	static int previousCrit = 0;
	static int startingNum = pCmd->command_number;

	const auto& pLocal = g_EntityCache.GetLocal( );
	if ( !pLocal ) { return; }

	const auto& pWeapon = g_EntityCache.GetWeapon( );
	if ( !pWeapon ) { return; }

	if ( g_GlobalInfo.m_bAttacking || IsAttacking( pCmd, pWeapon )/* || pCmd->buttons & IN_ATTACK*/ )
	{
		return;
	}

	const bool bRescanRequired = previousWeapon != pWeapon->entindex( );
	if ( bRescanRequired )
	{
		startingNum = pCmd->command_number;
		previousWeapon = pWeapon->entindex( );
		CritTicks.clear( );
	}

	if ( CritTicks.size( ) >= 256 )
	{
		return;
	}

	//CritBucketBP = *reinterpret_cast<float*>(pWeapon + 0xA54);
	ProtectData = true; //	stop shit that interferes with our crit bucket because it will BREAK it
	const int seedBackup = MD5_PseudoRandom( pCmd->command_number ) & MASK_SIGNED;
	for ( g_GlobalInfo.currentTickLoop = 0; g_GlobalInfo.currentTickLoop < loops; g_GlobalInfo.currentTickLoop++ )
	{
		const int cmdNum = startingNum + g_GlobalInfo.currentTickLoop;
		*I::RandomSeed = MD5_PseudoRandom( cmdNum ) & MASK_SIGNED;
		if ( pWeapon->WillCrit( ) )
		{
			CritTicks.push_back( cmdNum ); //	store our wish command number for later reference
			g_GlobalInfo.critTick = cmdNum;
		}
		else
			g_GlobalInfo.critTick = 0;
	}
	startingNum += loops;
	ProtectData = false; //	we no longer need to be protecting important crit data

	//*reinterpret_cast<float*>(pWeapon + 0xA54) = CritBucketBP;
	*reinterpret_cast< int * >( reinterpret_cast<DWORD>( pWeapon ) + 0xA5C ) = 0; //	dont comment this out, makes sure our crit mult stays as low as possible
	//	crit mult can reach a maximum value of 3!! which means we expend 3 crits WORTH from our bucket
	//	by forcing crit mult to be its minimum value of 1, we can crit more without directly fucking our bucket
	//	yes ProtectData stops this value from changing artificially, but it still changes when you fire and this is worth it imo.

	*I::RandomSeed = seedBackup;
}

void CCritHack::Run( CUserCmd *pCmd )
{
	if ( !IsEnabled( ) ) { return; }
	const auto& pLocal = g_EntityCache.GetLocal( );
	if ( !pLocal || pLocal->deadflag( ) || pLocal->IsDormant( ) ) { return; }
	const auto& pWeapon = g_EntityCache.GetWeapon( );
	if ( !pWeapon || !pWeapon->CanFireCriticalShot( false ) ) { return; }

	const int nItemDefIndex = pWeapon->m_iItemDefinitionIndex( );

	/*if ( g_GlobalInfo.m_nCurItemDefIndex != nItemDefIndex )
	{
		stats.flCritBucket = 300.f;
	}*/

	if ( g_GlobalInfo.m_WeaponType == EWeaponType::MELEE )
	{
		bIsMelee = true;
	}
	else
	{
		bIsMelee = false;
	}
	/*static bool init = false;
	if ( !init )
	{
		state_t state = *reinterpret_cast< state_t * >( reinterpret_cast< DWORD >( pWeapon ) + 0xAAC );
		init = true;
	}*/
	
	ScanForCrits( pCmd, 50 ); //	fill our vector slowly.

	const int closestGoodTick = LastGoodCritTick( pCmd ); //	retrieve our wish
	if ( IsAttacking( pCmd, pWeapon ) ) //	is it valid & should we even use it
	{
		iscrit_t crit;
		IsCrit( pLocal, pWeapon, crit );
		if ( ShouldCrit( ) )
		{
			if ( closestGoodTick < 0 ) { return; }
			pCmd->command_number = closestGoodTick; //	set our cmdnumber to our wish
			pCmd->random_seed = MD5_PseudoRandom( closestGoodTick ) & MASK_SIGNED; //	trash poopy whatever who cares
		}
		else if ( Vars::CritHack::AvoidRandom.var ) //	we don't want to crit
		{
			for ( int tries = 1; tries < 25; tries++ )
			{
				if ( std::find( CritTicks.begin( ), CritTicks.end( ), pCmd->command_number + tries ) != CritTicks.end( ) )
				{
					continue; //	what a useless attempt
				}
				pCmd->command_number += tries;
				pCmd->random_seed = MD5_PseudoRandom( pCmd->command_number ) & MASK_SIGNED;
				break; //	we found a seed that we can use to avoid a crit and have skipped to it, woohoo
			}
		}
	}
}

void CCritHack::Render( )
{
	if ( !I::EngineClient->IsInGame( ) || !I::EngineClient->IsConnected( ) || I::EngineVGui->IsGameUIVisible( ) || !Vars::CritHack::Indicators.var || !Vars::CritHack::Active.var ) { return; }

	if ( const auto &pLocal = g_EntityCache.GetLocal( ) )
	{
		if ( !pLocal || pLocal->deadflag( ) || pLocal->IsDormant( ) )
			return;

		if ( const auto &pWeapon = g_EntityCache.GetWeapon( ) )
		{
			if ( !pWeapon || pWeapon->IsDormant( ) )
				return;

			if ( pLocal->IsCritBoosted( ) )
			{
				g_Draw.OutlinedString( g_Fonts[ EFonts::IND ].m_dwFont, g_Draw.m_nScreenW * 0.5f, g_Draw.m_nScreenH * 0.6f, { 50, 150, 255, 255 }, ALIGN_CENTERHORIZONTAL, "crit boosted" );
			}
			else
			{
				if ( !AreRandomCritsEnabled( ) )
				{
					g_Draw.OutlinedString( g_Fonts[ EFonts::IND ].m_dwFont, g_Draw.m_nScreenW * 0.5f, g_Draw.m_nScreenH * 0.6f, { 150, 150, 150, 255 }, ALIGN_CENTERHORIZONTAL, "Server disabled crits" );
				}
				else
				{
					float critbucket = 300;
					switch ( pWeapon->GetSlot( ) )
					{
						case 0:
						{
							critbucket = stats.flCritBucket[ 0 ];
							break;
						}

						case 1:
						{
							critbucket = stats.flCritBucket[ 1 ];
							break;
						}

						case 2:
						{
							critbucket = stats.flCritBucket[ 2 ];
							break;
						}

						default: break;
					}

					if ( WeaponCanCrit( pWeapon ) )
					{
						const bool bIsMinigun = pWeapon->GetWeaponID( ) == TF_WEAPON_MINIGUN;
						int damage = bIsMinigun ? 330 : AttackDamage( pWeapon );
						int maxcrits = std::clamp( ( int )std::round( 1000.f / ( bIsMelee ? ( int )( damage * 0.5f ) : ( int )( damage * 3.0f ) ) ), 0, 100 );
						int crits = std::clamp( pWeapon->GetWeaponID( ) == TF_WEAPON_MINIGUN ? ( int )std::floor( critbucket / ( int )( damage * 3.0f ) ) : ( critbucket >= 999.f ) ? maxcrits : ( int )std::floor( critbucket / ( bIsMelee ? ( int )( damage * 0.5f ) : ( int )( damage * 3.0f ) ) ), 0, 100 );
						int nTextOffset = 0;
						int max = g_ConVars.tf_crit_cap->GetInt( );

						if ( !bIsMelee )
						{
							if ( g_GlobalInfo.m_bFoundCrit || CritTicks.size( ) > 1 )
							{
								Color_t maxcritscol = pWeapon->GetWeaponID( ) == TF_WEAPON_MINIGUN ? ( crits > 0 ? Color_t{ 0, 255, 0, 255 } : Color_t{ 255, 0, 0, 255 } ) : ( maxcrits > 0 ? Color_t{ 0, 255, 0, 255 } : Color_t{ 255, 0, 0, 255 } );
								g_Draw.OutlinedString( g_Fonts[ EFonts::IND ].m_dwFont, g_Draw.m_nScreenW * 0.5f, g_Draw.m_nScreenH * 0.6f, maxcritscol, ALIGN_CENTERHORIZONTAL, "%i/%i crits", crits, maxcrits );
								nTextOffset += g_Fonts[ EFonts::IND ].m_nTall;
								/*g_Draw.String( g_Fonts[ EFonts::IND ].m_dwFont, g_Draw.m_nScreenW * 0.5f, g_Draw.m_nScreenH * 0.7f + 100, { 50, 150, 255, 255 }, ALIGN_CENTERHORIZONTAL, "%i", damage );
								g_Draw.String( g_Fonts[ EFonts::IND ].m_dwFont, g_Draw.m_nScreenW * 0.5f, g_Draw.m_nScreenH * 0.7f + 120, { 50, 150, 255, 255 }, ALIGN_CENTERHORIZONTAL, "%i", damage * 3 );
								if ( stats.flCritBucket > 999.99f )
								{
									g_Draw.String( g_Fonts[ EFonts::IND ].m_dwFont, g_Draw.m_nScreenW * 0.5f, g_Draw.m_nScreenH * 0.6f + nTextOffset, { 50, 150, 255, 255 }, ALIGN_CENTERHORIZONTAL, "crit bucket full" );
									nTextOffset += g_Fonts[ EFonts::IND ].m_nTall;
								}*/
								const float rest = bIsMinigun ? stats.flCritBucket[ 0 ] : ( stats.flCritBucket[ pWeapon->GetSlot( ) ] - ( ( float )( crits ) * ( ( float )damage * 3.f ) ) );
																						//370 - ( 2 * ( 210 ) )
								const float ratio = std::clamp( rest / ( ( float )damage * 3.f ), 0.f, 1.f );
								if ( crits != maxcrits )
								{
									g_Draw.Rect( g_Draw.m_nScreenW * 0.5f - 24, g_Draw.m_nScreenH * 0.6f + 19, 48, 5, { 0, 0, 0, 255 } );
									g_Draw.Rect( g_Draw.m_nScreenW * 0.5f - 23, g_Draw.m_nScreenH * 0.6f + 20, 46 * ratio, 3, { Vars::Menu::Colors::CustomTitle } );
									g_Draw.OutlinedRect( g_Draw.m_nScreenW * 0.5f - 24, g_Draw.m_nScreenH * 0.6f + 19, 48, 5, { 0, 0, 0, 255 } );
								}
								/*g_Draw.String( g_Fonts[ EFonts::IND ].m_dwFont, g_Draw.m_nScreenW * 0.5f, g_Draw.m_nScreenH * 0.7f + 40, { 50, 150, 255, 255 }, ALIGN_CENTERHORIZONTAL, "%i", crits );
								g_Draw.String( g_Fonts[ EFonts::IND ].m_dwFont, g_Draw.m_nScreenW * 0.5f, g_Draw.m_nScreenH * 0.7f + 60, { 50, 150, 255, 255 }, ALIGN_CENTERHORIZONTAL, "%i", damage );
								g_Draw.String( g_Fonts[ EFonts::IND ].m_dwFont, g_Draw.m_nScreenW * 0.5f, g_Draw.m_nScreenH * 0.7f + 80, { 50, 150, 255, 255 }, ALIGN_CENTERHORIZONTAL, "%i", damage * 3 );
								g_Draw.String( g_Fonts[ EFonts::IND ].m_dwFont, g_Draw.m_nScreenW * 0.5f, g_Draw.m_nScreenH * 0.7f + 100, { 50, 150, 255, 255 }, ALIGN_CENTERHORIZONTAL, "%.2f", stats.flCritBucket[ pWeapon->GetSlot( ) ] );*/
							}
							else if ( ( !g_GlobalInfo.m_bFoundCrit && g_GlobalInfo.currentTickLoop ) && CritTicks.size( ) < 1 )
							{
								g_Draw.OutlinedString( g_Fonts[ EFonts::IND ].m_dwFont, g_Draw.m_nScreenW * 0.5f, g_Draw.m_nScreenH * 0.6f, { 255, 0, 0, 255 }, ALIGN_CENTERHORIZONTAL, "%i/%i crits", crits, maxcrits );
								g_Draw.OutlinedString( g_Fonts[ EFonts::IND ].m_dwFont, g_Draw.m_nScreenW * 0.5f, g_Draw.m_nScreenH * 0.6f + 20, { 255, 0, 0, 255 }, ALIGN_CENTERHORIZONTAL, "Crit Banned" );
							}
						}
						else
						{
							Color_t maxcritscol = maxcrits > 0 ? Color_t{ 0, 255, 0, 255 } : Color_t{ 255, 0, 0, 255 };
							g_Draw.OutlinedString( g_Fonts[ EFonts::IND ].m_dwFont, g_Draw.m_nScreenW * 0.5f, g_Draw.m_nScreenH * 0.6f, maxcritscol, ALIGN_CENTERHORIZONTAL, "%i/%i crits", crits, maxcrits );
							nTextOffset += g_Fonts[ EFonts::IND ].m_nTall;
							/*g_Draw.String( g_Fonts[ EFonts::IND ].m_dwFont, g_Draw.m_nScreenW * 0.5f, g_Draw.m_nScreenH * 0.7f + 140, { 50, 150, 255, 255 }, ALIGN_CENTERHORIZONTAL, "%i", damage );
							g_Draw.String( g_Fonts[ EFonts::IND ].m_dwFont, g_Draw.m_nScreenW * 0.5f, g_Draw.m_nScreenH * 0.7f + 160, { 50, 150, 255, 255 }, ALIGN_CENTERHORIZONTAL, "%i", damage * 0.5f );*/
						}
					}
				}

				/*g_Draw.String( g_Fonts[ EFonts::IND ].m_dwFont, g_Draw.m_nScreenW * 0.5f, g_Draw.m_nScreenH * 0.7f, { 50, 150, 255, 255 }, ALIGN_CENTERHORIZONTAL, "iscrit true" );
				//g_Draw.String( g_Fonts[ EFonts::IND ].m_dwFont, g_Draw.m_nScreenW * 0.5f, g_Draw.m_nScreenH * 0.7f + 20, { 50, 150, 255, 255 }, ALIGN_CENTERHORIZONTAL, "%i", crit );
				g_Draw.String( g_Fonts[ EFonts::IND ].m_dwFont, g_Draw.m_nScreenW * 0.5f, g_Draw.m_nScreenH * 0.7f + 40, { 50, 150, 255, 255 }, ALIGN_CENTERHORIZONTAL, "%.2f", stats.flCritBucket[ pWeapon->GetSlot( ) ] );
				g_Draw.String( g_Fonts[ EFonts::IND ].m_dwFont, g_Draw.m_nScreenW * 0.5f, g_Draw.m_nScreenH * 0.7f + 60, { 50, 150, 255, 255 }, ALIGN_CENTERHORIZONTAL, "%i", stats.iNumAttacks );
				g_Draw.String( g_Fonts[ EFonts::IND ].m_dwFont, g_Draw.m_nScreenW * 0.5f, g_Draw.m_nScreenH * 0.7f + 80, { 50, 150, 255, 255 }, ALIGN_CENTERHORIZONTAL, "%i", stats.iNumCrits );
				g_Draw.String( g_Fonts[ EFonts::IND ].m_dwFont, g_Draw.m_nScreenW * 0.5f, g_Draw.m_nScreenH * 0.7f + 180, { 50, 150, 255, 255 }, ALIGN_CENTERHORIZONTAL, "%.2f", state.flCritEndTime );
				g_Draw.String( g_Fonts[ EFonts::IND ].m_dwFont, g_Draw.m_nScreenW * 0.5f, g_Draw.m_nScreenH * 0.7f + 200, { 50, 150, 255, 255 }, ALIGN_CENTERHORIZONTAL, "%i", bStreamCrits );*/

			}
		}
	}
}