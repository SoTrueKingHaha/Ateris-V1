#include "Backtrack.h"
#include "../../Assistance/Aimbot/AimbotHitscan/AimbotHitscan.h"

bool CBacktrack::IsTracked( const TickRecord &record )
{
	return I::GlobalVars->curtime - record.flCreateTime < 1.f;
}

//	should return true if the current position on the client has a lag comp record created for it by the server (SHOULD)
//	if the player has updated more than once, only the first update will have a backtrack record (i think)
//	dont use this yet
bool CBacktrack::IsSimulationReliable( CTFPlayer *pEntity )
{
	const float flSimTimeDelta = pEntity->m_flSimulationTime( ) - pEntity->GetOldSimulationTime( );
	const int iTicksSimTimeDelta = flSimTimeDelta / I::GlobalVars->interval_per_tick;
	return iTicksSimTimeDelta == 1;
}

bool CBacktrack::WithinRewind( const TickRecord &record )
{
	//	check if we can go to this tick, ie, within 200ms of us
	const auto pLocal = g_EntityCache.GetLocal( );
	const auto iNetChan = I::EngineClient->GetNetChannelInfo( );

	if ( !pLocal || pLocal->deadflag( ) || pLocal->IsDormant( ) || !iNetChan ) { return false; }

	const int iTargetTick = TIME_TO_TICKS( record.flSimTime - g_GlobalInfo.lerpTime );
	const float flCorrect = std::clamp( 0.f + TICKS_TO_TIME( TIME_TO_TICKS( g_GlobalInfo.lerpTime ) ), 0.f, g_ConVars.sv_maxunlag->GetFloat( ) );
	const float flDelta = fabsf( flCorrect - ( TICKS_TO_TIME( I::GlobalVars->tickcount - iTargetTick ) ) );

	return flDelta < .200f - TICKS_TO_TIME( 2 ); //	in short, check if the record is +- 200ms from us
}

void CBacktrack::CleanRecords( )
{
	for ( const auto &pEntity : g_EntityCache.GetGroup( EEntGroup::PLAYERS_ENEMIES ) )
	{
		const auto &pEnemy = pEntity->As<CTFPlayer>( );
		if ( !pEnemy ) { continue; }

		if ( pEnemy->IsDormant( ) || pEnemy->deadflag( ) || pEnemy->GetClassId( ) != EClassIds::CTFPlayer )
		{
			mRecords[ pEnemy ].clear( );
			continue;
		}

		if ( mRecords[ pEnemy ].empty( ) ) { continue; }
		if ( !IsTracked( mRecords[ pEnemy ].back( ) ) ) { mRecords[ pEnemy ].pop_back( ); }
		if ( mRecords[ pEnemy ].size( ) > 67 ) { mRecords[ pEnemy ].pop_back( ); }
	}
}

void CBacktrack::MakeRecords( )
{
	const float flCurTime = I::GlobalVars->curtime;
	const int iTickcount = I::GlobalVars->tickcount;
	if ( iLastCreationTick == iTickcount ) { return; }
	iLastCreationTick = iTickcount;

	for ( const auto &pEntity : g_EntityCache.GetGroup( EEntGroup::PLAYERS_ENEMIES ) )
	{
		const auto &pEnemy = pEntity->As<CTFPlayer>( );
		if ( !pEnemy || pEnemy->deadflag( ) || pEnemy->IsDormant( ) ) { continue; }
		if ( pEnemy->GetClassId( ) != EClassIds::CTFPlayer ) { return; }
		const float flSimTime = pEnemy->m_flSimulationTime( ), flOldSimTime = pEnemy->GetOldSimulationTime( );

		//Utils::ConLog("LagCompensation", tfm::format("SimTime = %.1f\nOldSimTime = %.1f", flSimTime, flOldSimTime).c_str(), {255, 0, 0, 255});

		if ( flSimTime != flOldSimTime )
		{
			//	create record on simulated players
			//Utils::ConLog("LagCompensation", "Setting Up Bones", {255, 0, 0, 255});
			matrix3x4_t bones[ 128 ];
			if ( !pEnemy->SetupBones( bones, 128, 0x0007FF00, flSimTime ) ) { continue; }
			//Utils::ConLog("LagCompensation", "Creating Record", {255, 0, 0, 255});
			const Vec3 vOrigin = pEnemy->m_vecOrigin( );
			if ( !mRecords[ pEnemy ].empty( ) )
			{
				// as long as we have 1 record we can check for lagcomp breaking here
				const Vec3 vPrevOrigin = mRecords[ pEnemy ].front( ).vOrigin;
				const Vec3 vDelta = vOrigin - vPrevOrigin;
				if ( vDelta.Length2DSqr( ) > 4096.f )
				{
					/*Utils::ConLog("LagCompensation", "Cleared borked records", {255, 0, 0, 255});*/
					mRecords[ pEnemy ].clear( );
				}
			}

			mRecords[ pEnemy ].push_front( {
				flSimTime,
				flCurTime,
				iTickcount,
				mDidShoot[ pEnemy->entindex( ) ],
				*reinterpret_cast< BoneMatrixes * >( &bones ),
				pEnemy->GetHitboxPos( HITBOX_HEAD ),
				vOrigin,
				pEnemy->GetAbsAngles( ),
											} );
		}

		//cleanup
		mDidShoot[ pEnemy->entindex( ) ] = false;
		if ( mRecords[ pEnemy ].size( ) > 67 )
		{
			/*Utils::ConLog("LagCompensation", "Manually removed tick record", {255, 0, 0, 255});*/
			mRecords[ pEnemy ].pop_back( );
		} //	schizoid check
	}
}

void CBacktrack::PlayerHurt( IGameEvent *pEvent )
{
	//const int iIndex = I::EngineClient->GetPlayerForUserID(pEvent->GetInt("userid"));
	//if (CTFPlayer* pEntity = I::ClientEntityList->GetClientEntity(iIndex)){
	//	mRecords[pEntity].clear();	//	bone cache has gone to poop for this entity, they must be cleansed in holy fire :smiling_imp:
	//}
}

void CBacktrack::Restart( )
{
	mRecords.clear( );
}

void CBacktrack::FrameStageNotify( )
{
	const auto &pLocal = g_EntityCache.GetLocal( );
	INetChannelInfo *iNetChan = I::EngineClient->GetNetChannelInfo( );
	if ( !pLocal || pLocal->deadflag( ) || pLocal->IsDormant( ) || !iNetChan ) {
		return Restart( );
	}

	MakeRecords( );
	CleanRecords( );
}

void CBacktrack::ReportShot( int iIndex )
{
	const auto& pEntity = I::ClientEntityList->GetClientEntity( iIndex );
	if ( !pEntity ) { return; }
	mDidShoot[ pEntity->entindex( ) ] = true;
}

std::optional<TickRecord> CBacktrack::GetHitRecord( CUserCmd *pCmd, CTFPlayer *pEntity, const Vec3 vAngles, const Vec3 vPos )
{
	std::optional<TickRecord> cReturnRecord{};
	float flLastAngle = 45.f;

	for ( const auto &rCurQuery : mRecords[ pEntity ] )
	{
		if ( !WithinRewind( rCurQuery ) ) { continue; }
		for ( int iCurHitbox = 0; iCurHitbox < 18; iCurHitbox++ )
		{
			//	it's possible to set entity positions and bones back to this record and then see what hitbox we will hit and rewind to that record, bt i dont wanna
			const Vec3 vHitboxPos = pEntity->GetHitboxPosMatrix( iCurHitbox, ( matrix3x4_t * )( &rCurQuery.BoneMatrix.BoneMatrix ) );
			const Vec3 vAngleTo = Utils::CalcAngle( vPos, vHitboxPos );
			const float flFOVTo = Utils::CalcFov( vAngles, vAngleTo );
			if ( flFOVTo < flLastAngle )
			{
				cReturnRecord = rCurQuery;
				flLastAngle = flFOVTo;
			}
		}
	}
	return cReturnRecord;
}

std::optional<TickRecord> CBacktrack::Run( CUserCmd *pCmd )
{
	if ( !Vars::Backtrack::Active.var ) { return std::nullopt; }
	const auto& pLocal = g_EntityCache.GetLocal( );
	if ( !pLocal || pLocal->deadflag( ) || pLocal->IsDormant( ) ) { return std::nullopt; }
	//UpdateDatagram( );
	if ( g_AimbotHitscan.IsAttacking( pCmd, g_EntityCache.GetWeapon( ) ) /*( pCmd->buttons & IN_ATTACK ) && g_GlobalInfo.m_bWeaponCanAttack*/ )
	{
		const Vec3 vShootPos = pLocal->GetShootPos( );
		const Vec3 vAngles = pCmd->viewangles;

		std::optional<TickRecord> cReturnTick;
		for ( const auto &pEntity : g_EntityCache.GetGroup( EEntGroup::PLAYERS_ENEMIES ) )
		{
			const auto &pEnemy = pEntity->As<CTFPlayer>( );
			if ( !pEnemy || pEnemy->deadflag( ) || pEnemy->IsDormant( ) ) { continue; } //	dont scan
			
			player_info_t pInfo{}; //	dont care about ignored players
			if ( !I::EngineClient->GetPlayerInfo( pEnemy->entindex( ), &pInfo ) )
			{
				if ( pEnemy->PlayerOnFriendsList( ) ) { continue; }
			}

			if ( const std::optional<TickRecord> checkRec = GetHitRecord( pCmd, pEnemy, vAngles, vShootPos ) )
			{
				cReturnTick = checkRec;
				break;
			}
		}
		if ( cReturnTick )
		{
			pCmd->tick_count = TIME_TO_TICKS( cReturnTick->flSimTime + g_GlobalInfo.lerpTime );
			return std::nullopt;
		}
	}
	return std::nullopt;
}

std::optional<TickRecord> CBacktrack::Aimbot( CTFPlayer *pEntity, BacktrackMode iMode, int nHitbox )
{
	const auto& pLocal = g_EntityCache.GetLocal( );
	if ( !pLocal ) { return std::nullopt; }
	if ( mRecords[ pEntity ].empty( ) ) { return std::nullopt; }
	switch ( iMode )
	{
		case BacktrackMode::ALL:
		{
			for ( const auto &rCurQuery : mRecords[ pEntity ] )
			{
				if ( !WithinRewind( rCurQuery ) || !IsTracked( rCurQuery ) ) { continue; }
				const Vec3 vHitboxPos = pEntity->GetHitboxPosMatrix( nHitbox, ( matrix3x4_t * )( &rCurQuery.BoneMatrix.BoneMatrix ) );
				if ( Utils::VisPos( pLocal, pEntity, pLocal->GetShootPos( ), vHitboxPos ) ) { return rCurQuery; }
			}
			return std::nullopt;
		}

		case BacktrackMode::FIRST:
		{
			if ( std::optional<TickRecord> FirstRecord = GetFirstRecord( pEntity ) )
			{
				const Vec3 vHitboxPos = pEntity->GetHitboxPosMatrix( nHitbox, ( matrix3x4_t * )( &FirstRecord->BoneMatrix.BoneMatrix ) );
				if ( Utils::VisPos( pLocal, pEntity, pLocal->GetShootPos( ), vHitboxPos ) ) { return FirstRecord; }
			}
			return std::nullopt;
		}

		case BacktrackMode::LAST:
		{
			if ( std::optional<TickRecord> LastRecord = GetLastRecord( pEntity ) )
			{
				const Vec3 vHitboxPos = pEntity->GetHitboxPosMatrix( nHitbox, ( matrix3x4_t * )( &LastRecord->BoneMatrix.BoneMatrix ) );
				if ( Utils::VisPos( pLocal, pEntity, pLocal->GetShootPos( ), vHitboxPos ) ) { return LastRecord; }
			}
			return std::nullopt;
		}

		case BacktrackMode::ADAPTIVE:
		{
			std::optional<TickRecord> ReturnTick{};
			for ( const auto &rCurQuery : mRecords[ pEntity ] )
			{
				if ( !WithinRewind( rCurQuery ) || !IsTracked( rCurQuery ) ) { continue; }
				const Vec3 vHitboxPos = pEntity->GetHitboxPosMatrix( nHitbox, ( matrix3x4_t * )( &rCurQuery.BoneMatrix.BoneMatrix ) );
				if ( Utils::VisPos( pLocal, pEntity, pLocal->GetShootPos( ), vHitboxPos ) ) { ReturnTick = rCurQuery; }
				if ( ReturnTick.has_value( ) )
				{
					if ( ReturnTick->bOnShot ) { break; }
				}
			}
			return ReturnTick;
		}

		case BacktrackMode::ONSHOT:
		{
			for ( const auto &rCurQuery : mRecords[ pEntity ] )
			{
				if ( !WithinRewind( rCurQuery ) || !IsTracked( rCurQuery ) ) { continue; }
				const Vec3 vHitboxPos = pEntity->GetHitboxPosMatrix( nHitbox, ( matrix3x4_t * )( &rCurQuery.BoneMatrix.BoneMatrix ) );
				if ( Utils::VisPos( pLocal, pEntity, pLocal->GetShootPos( ), vHitboxPos ) )
				{
					if ( rCurQuery.bOnShot ) { return rCurQuery; }
				}
			}
			return std::nullopt;
		}
	}
	return std::nullopt;
}

std::deque<TickRecord> *CBacktrack::GetRecords( CTFPlayer *pEntity )
{
	if ( mRecords[ pEntity ].empty( ) )
	{
		return nullptr;
	}

	return &mRecords[ pEntity ];
}

std::optional<TickRecord> CBacktrack::GetLastRecord( CTFPlayer *pEntity )
{
	if ( mRecords[ pEntity ].empty( ) ) { return std::nullopt; }
	std::optional<TickRecord> rReturnRecord = std::nullopt;
	for ( const auto &rCurQuery : mRecords[ pEntity ] )
	{
		if ( !IsTracked( rCurQuery ) || !WithinRewind( rCurQuery ) ) { continue; }
		rReturnRecord = rCurQuery;
	}
	return rReturnRecord;
}

std::optional<TickRecord> CBacktrack::GetFirstRecord( CTFPlayer *pEntity )
{
	if ( mRecords[ pEntity ].empty( ) ) { return std::nullopt; }
	std::optional<TickRecord> rReturnRecord = std::nullopt;
	for ( const auto &rCurQuery : mRecords[ pEntity ] )
	{
		if ( !IsTracked( rCurQuery ) || !WithinRewind( rCurQuery ) ) { continue; }
		return rCurQuery;
	}
	return std::nullopt;
}