#pragma once
#include "../../../SDK/SDK.h"

#pragma warning ( disable : 4091 )

class CIncomingSequence
{
public:
	int InReliableState;
	int SequenceNr;
	float CurTime;

	CIncomingSequence( int inState, int seqNr, float time )
	{
		InReliableState = inState;
		SequenceNr = seqNr;
		CurTime = time;
	}
};

using BoneMatrixes = struct
{
	float BoneMatrix[ 128 ][ 3 ][ 4 ];
};

struct TickRecord
{
	float flSimTime = 0.f;
	float flCreateTime = 0.f;
	int iTickCount = 0;
	bool bOnShot = false;
	BoneMatrixes BoneMatrix{};
	Vec3 vHead = {};
	Vec3 vOrigin = {};
	Vec3 vAngles = {};
};

enum class BacktrackMode
{
	ALL,		//	iterates through every tick (slow probably)
	FIRST,		//	first
	LAST,		//	last
	ADAPTIVE,	//	prefers on shot records, last
	ONSHOT,		//	only returns on shot records
};

class CBacktrack
{
public:
	bool IsTracked( const TickRecord &record );
	bool IsSimulationReliable( CTFPlayer *pEntity );
	//bool IsBackLagComped(CBaseEntity* pEntity);

	//	utils
	void CleanRecords( );
	void MakeRecords( );
	std::optional<TickRecord> GetHitRecord( CUserCmd *pCmd, CTFPlayer *pEntity, Vec3 vAngles, Vec3 vPos );

	//	data
	std::unordered_map<CTFPlayer *, std::deque<TickRecord>> mRecords;
	std::unordered_map<int, bool> mDidShoot;
	int iLastCreationTick = 0;

public:
	bool WithinRewind( const TickRecord &record );
	bool CanHitOriginal( CTFPlayer *pEntity );
	void PlayerHurt( IGameEvent *pEvent ); //	called on player_hurt event
	void Restart( ); //	called whenever lol
	void FrameStageNotify( ); //	called in FrameStageNotify
	void ReportShot( int iIndex );
	std::deque<TickRecord> *GetRecords( CTFPlayer *pEntity );
	std::optional<TickRecord> Aimbot( CTFPlayer *pEntity, BacktrackMode iMode, int nHitbox );
	std::optional<TickRecord> GetLastRecord( CTFPlayer *pEntity );
	std::optional<TickRecord> GetFirstRecord( CTFPlayer *pEntity );
	std::optional<TickRecord> Run( CUserCmd *pCmd ); //	returns a valid record
};

inline CBacktrack g_Backtrack;