#include "FakeLag.h"

bool CFakeLag::IsAllowed( CUserCmd *pCmd, CTFPlayer *pLocal ) {

	const int doubleTapAllowed = ( g_GlobalInfo.m_nTicksToShift + 1 ) - ( g_GlobalInfo.m_nTicksToShift - g_GlobalInfo.m_nShifted );

	// Failsafe, in case we're trying to choke too many ticks
	if ( ChokeCounter > 23 ) {
		return false;
	}

	if ( ChokeCounter >= ChosenAmount ) {
		return false;
	}

	// Are we attacking? TODO: Add more logic here
	if ( ( pCmd->buttons & IN_ATTACK ) && g_GlobalInfo.m_bWeaponCanAttack ) {
		return false;
	}

	// Is a fakelag key set and pressed?
	if ( !( GetAsyncKeyState( Vars::Misc::CL_Move::FakelagKey.var ) & 0x8000) && Vars::Misc::CL_Move::FakelagOnKey.var && Vars::Misc::CL_Move::FakelagMode.var == 0 ) {
		return false;
	}

	// Do we have enough velocity for velocity mode?
	if ( Vars::Misc::CL_Move::FakelagMode.var == FL_Velocity && pLocal->m_vecVelocity( ).Length2D( ) < 20.f )
	{
		return false;
	}

	// Are we recharging or shifting ticks?
	if ( ChokeCounter >= doubleTapAllowed || g_GlobalInfo.m_bRecharging || g_GlobalInfo.m_bRechargeQueued || g_GlobalInfo.m_bShouldShift ) {
		return false;
	}

	return true;
}

void CFakeLag::OnTick( CUserCmd *pCmd, bool *pSendPacket ) {
	g_GlobalInfo.m_bChoking = false;	//	do this first
	if ( !Vars::Misc::CL_Move::Fakelag.var ) { return; }

	// Set the selected choke amount (if not random)
	if ( Vars::Misc::CL_Move::FakelagMode.var != FL_Random ) {
		ChosenAmount = Vars::Misc::CL_Move::FakelagValue.var;
	}

	const auto& pLocal = g_EntityCache.GetLocal( );
	if ( !pLocal || pLocal->deadflag( ) || pLocal->IsDormant( ) )
	{

		*pSendPacket = true;
		ChokeCounter = 0;

		return;
	}

	static bool bSet = false;
	if ( Vars::Misc::CL_Move::FakelagSafe.var && !bSet )
	{
		if ( pLocal->IsOnGround( ) )
		{
			if ( Vars::Misc::CL_Move::FakelagValue.var > 14 )
				Vars::Misc::CL_Move::FakelagValue.var = 14;

			Vars::Misc::CL_Move::FakelagMax.var = 14;
		}
		bSet = true;
	}

	else if ( !Vars::Misc::CL_Move::FakelagSafe.var && bSet )
	{
		bSet = false;
	}

	else if ( !Vars::Misc::CL_Move::FakelagSafe.var )
	{
		static bool bSet1 = false;

		static int nValue = 0;
		static int nMax = 0;
		if ( !pLocal->IsOnGround( ) && !bSet1 )
		{
			nValue = Vars::Misc::CL_Move::FakelagValue.var;
			nMax = Vars::Misc::CL_Move::FakelagMax.var;

			Vars::Misc::CL_Move::FakelagValue.var = 21;
			Vars::Misc::CL_Move::FakelagMax.var = 21;

			bSet1 = true;
		}
		else if ( pLocal->IsOnGround( ) && bSet1 )
		{
			Vars::Misc::CL_Move::FakelagValue.var = nValue;
			Vars::Misc::CL_Move::FakelagMax.var = nMax;
			bSet1 = false;
		}
	}

	// Are we even allowed to choke?
	if ( !IsAllowed( pCmd, pLocal ) ) {
		g_GlobalInfo.m_bChoking = false;
		*pSendPacket = true;
		// Set a new random amount (if desired)
		if ( Vars::Misc::CL_Move::FakelagMode.var == FL_Random ) { ChosenAmount = Utils::RandIntSimple( Vars::Misc::CL_Move::FakelagMin.var, Vars::Misc::CL_Move::FakelagMax.var ); }
		ChokeCounter = 0;
		return;
	}

	g_GlobalInfo.m_bChoking = true;
	*pSendPacket = false;
	ChokeCounter++;
}